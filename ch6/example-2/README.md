# React-Scan 데모

이 프로젝트는 React 애플리케이션의 성능 문제를 식별하고 해결하기 위한 react-scan의 사용을 보여줍니다.

## 개요

React-scan은 React 애플리케이션의 불필요한 리렌더링과 성능 병목 현상을 식별하고 시각화하는 도구입니다. 이 데모는 다음을 보여줍니다:

1. 성능 문제가 있는 최적화되지 않은 버전:
   - 불필요한 컴포넌트 리렌더링
   - 모든 렌더링에서 수행되는 무거운 계산
   - 비효율적인 데이터 처리 패턴

2. 다음을 사용하여 이러한 문제를 해결하는 최적화된 버전:
   - 불필요한 리렌더링을 방지하는 React.memo
   - 비용이 많이 드는 계산을 위한 useMemo
   - 안정적인 함수 참조를 위한 useCallback
   - 효율적인 데이터 처리 패턴

## 시작하기

1. 의존성 설치:
   ```
   npm install
   ```

2. 개발 서버 시작:
   ```
   npm run dev
   ```

3. 브라우저에서 애플리케이션을 열고 최적화되지 않은 버전과 최적화된 버전 간의 차이점을 관찰하세요.

## 작동 방식

이 데모에는 다음이 포함됩니다:

- 최적화되지 않은 구현과 최적화된 구현 간에 전환할 수 있는 인터페이스
- 각 컴포넌트의 렌더링 횟수를 보여주는 콘솔 로그
- 컴포넌트가 리렌더링될 때 이를 강조 표시하는 React-scan

## 시연된 주요 성능 문제

1. **불필요한 리렌더링**: 최적화되지 않은 버전의 카운터 상태는 props가 변경되지 않았음에도 매초 모든 컴포넌트가 리렌더링되도록 합니다.

2. **무거운 계산**: ExpensiveList 컴포넌트는 최적화되지 않은 버전에서 모든 렌더링마다 불필요하게 반복되는 비용이 많이 드는 작업을 시뮬레이션합니다.

3. **비효율적인 데이터 처리**: Summary 컴포넌트는 최적화되지 않은 버전에서 여러 번의 배열 순회를 수행합니다.

4. **메모이제이션 누락**: 최적화되지 않은 버전은 모든 렌더링에서 필터링된 데이터를 재계산합니다.

## 적용된 최적화

1. **React.memo**: props가 변경되지 않았을 때 컴포넌트가 리렌더링되는 것을 방지합니다.

2. **useMemo**: 비용이 많이 드는 계산을 캐싱하고 의존성이 변경될 때만 재계산합니다.

3. **useCallback**: 자식 컴포넌트에 전달되는 콜백에 대해 안정적인 함수 참조를 제공합니다.

4. **효율적인 데이터 처리**: 최적화된 버전은 단일 패스 작업과 같은 더 효율적인 데이터 처리 패턴을 사용합니다.

## React-Scan 소개

React-scan은 컴포넌트 렌더링을 시각화하고 잠재적인 최적화를 강조함으로써 개발자가 React 애플리케이션의 성능 문제를 식별하는 데 도움을 주는 강력한 도구입니다.

- 코드 변경이 필요 없음
- 자주 리렌더링되는 컴포넌트를 강조 표시
- 스크립트 태그, npm 또는 CLI를 통해 작동

자세한 내용은 [react-scan.com](https://react-scan.com)을 방문하세요.
